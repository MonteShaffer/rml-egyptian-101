<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>languageWheel (SVG two-layer) + Monad E</title>
<style>
  body{
    margin:0;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#fdf6e3;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }

  /* Container circle styling (background + border) */
  .lw-container{
    position:relative;
    border-radius:50%;
    overflow:hidden;
  }

  /* SVG fills the container */
  .lw-svg{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
  }

  /* ---------- Geometry layer styles ---------- */
  .lw-centerline{
    stroke:#333;
    stroke-width:1;
    stroke-dasharray:6 6;
    opacity:0.5;
    shape-rendering:crispEdges;
  }

  .lw-center-dot{
    fill:#111;
  }

  .lw-radial{
    stroke:rgba(0,0,0,0.55);
    stroke-width:2;
    shape-rendering:crispEdges;
  }

  .lw-tickdot{
    fill:#d33;
  }

  .lw-pentagram{
    stroke:rgba(120, 0, 140, 0.75);
    stroke-width:2;
    fill:none;
    shape-rendering:geometricPrecision;
  }

  /* Monad ellipse (geometry) */
  .lw-monad-ellipse{
    stroke:#1f5fbf;
    stroke-width:2;
    fill:rgba(31,95,191,0.08);
  }

  /* ---------- Label layer styles ---------- */
  .lw-label{
    fill:#111;
    font-size:18px;
    font-weight:700;
    dominant-baseline:middle;
    text-anchor:middle;
    user-select:none;
  }

  .lw-monad-label{
    fill:#1f5fbf;
    font-size:18px;
    font-weight:800;
    dominant-baseline:middle;
    text-anchor:middle;
    user-select:none;
  }
</style>
</head>
<body>

<div id="wheel"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
(function($){
  const NS = "http://www.w3.org/2000/svg";

  function svgEl(name, attrs){
    const el = document.createElementNS(NS, name);
    if(attrs){
      for(const k in attrs) el.setAttribute(k, attrs[k]);
    }
    return el;
  }

  // thetaDeg: 0 at north, positive clockwise
  function polarToXY(cx, cy, r, thetaDeg){
    const t = thetaDeg * Math.PI / 180;
    const x = cx + r * Math.sin(t);
    const y = cy - r * Math.cos(t);
    return {x, y};
  }

  $.fn.languageWheel = function(opts){
    const settings = $.extend(true, {
      unitRadiusPx: 300,              // "unit radius = 1" in pixels
      svgPadFactor: 0.10,             // 10% padding so labels don't clip
      circleBg: "#f0f8ff",
      circleBorder: "#1a1a1a",
      borderWidth: 2,

      // Toggle groups
      showClasses: {
        primalVowels: true,
        monad: true
      },

      // Debug toggles for primal geometry
      showCenterCross: true,
      showRadials: true,
      showTicks: true,
      showPentagram: true,
      showCenterDot: true,

      // Primal vowel layout
      primalLabels: ["A","I","U","O","ʔ"],
      primalStartThetaDeg: -22,       // A is 22° left of north
      primalStepDeg: 72,              // 360/5
      primalRadiusFactor: 1.0,        // primals at the circle edge

      // Monad E settings
      monad: {
        label: "E",
        offset: -1/3,                 // up from true center by 1/3 radius
        // Ellipse size as unit-radius multipliers
        rxFactor: 0.085,              // horizontal radius (tweak as desired)
        ryFactor: 0.060               // vertical radius (tweak as desired)
      }
    }, opts);

    return this.each(function(){
      const $host = $(this);
      $host.empty();

      const size = settings.unitRadiusPx * 2;
      const cx = settings.unitRadiusPx;
      const cy = settings.unitRadiusPx;
      const primalR = settings.unitRadiusPx * settings.primalRadiusFactor;

      // container circle (bg + border)
      $host
        .addClass("lw-container")
        .css({
          width: size + "px",
          height: size + "px",
          background: settings.circleBg,
          border: settings.borderWidth + "px solid " + settings.circleBorder
        });

      // SVG root with padded viewBox
      const pad = settings.unitRadiusPx * settings.svgPadFactor;
      const vbSize = size + pad * 2;

      const svg = svgEl("svg", {
        class: "lw-svg",
        viewBox: `-${pad} -${pad} ${vbSize} ${vbSize}`,
        xmlns: NS
      });

      // Two layers
      const gGeom = svgEl("g", { class: "lw-geom" });   // layer 1
      const gLbls = svgEl("g", { class: "lw-labels" }); // layer 2
      svg.appendChild(gGeom);
      svg.appendChild(gLbls);
      $host[0].appendChild(svg);

      // ----- Helper draw methods -----
      function drawLine(parent, x1,y1,x2,y2, cls){
        const el = svgEl("line", { x1, y1, x2, y2, class: cls });
        parent.appendChild(el);
        return el;
      }
      function drawCircle(parent, x,y,r, cls){
        const el = svgEl("circle", { cx:x, cy:y, r, class: cls });
        parent.appendChild(el);
        return el;
      }
      function drawText(parent, x,y, text, cls){
        const el = svgEl("text", { x, y, class: cls });
        el.textContent = text;
        parent.appendChild(el);
        return el;
      }
      function drawEllipse(parent, x,y, rx, ry, cls){
        const el = svgEl("ellipse", { cx:x, cy:y, rx, ry, class: cls });
        parent.appendChild(el);
        return el;
      }

      // ----- Compute primal positions -----
      const primals = [];
      for(let i=0; i<5; i++){
        const theta = settings.primalStartThetaDeg + i * settings.primalStepDeg;
        const p = polarToXY(cx, cy, primalR, theta);
        primals.push({ ...p, theta, label: settings.primalLabels[i] });
      }

      // ----- GEOM LAYER (layer 1) -----
      if(settings.showCenterCross){
        drawLine(gGeom, cx, 0, cx, size, "lw-centerline");
        drawLine(gGeom, 0, cy, size, cy, "lw-centerline");
      }
      if(settings.showCenterDot){
        drawCircle(gGeom, cx, cy, 3, "lw-center-dot");
      }

      // Monad ellipse (GEOM)
      let monadX = cx, monadY = cy;
      if(settings.showClasses.monad){
        monadY = cy + (settings.monad.offset * settings.unitRadiusPx);
        const rx = settings.monad.rxFactor * settings.unitRadiusPx;
        const ry = settings.monad.ryFactor * settings.unitRadiusPx;

        drawEllipse(gGeom, monadX, monadY, rx, ry, "lw-monad-ellipse");
      }

      // Radials + tick dots
      if(settings.showRadials){
        for(const p of primals){
          drawLine(gGeom, cx, cy, p.x, p.y, "lw-radial");

          if(settings.showTicks){
            const t1 = { x: cx + (p.x - cx) * (1/3), y: cy + (p.y - cy) * (1/3) };
            const t2 = { x: cx + (p.x - cx) * (2/3), y: cy + (p.y - cy) * (2/3) };
            drawCircle(gGeom, t1.x, t1.y, 3, "lw-tickdot");
            drawCircle(gGeom, t2.x, t2.y, 3, "lw-tickdot");
          }
        }
      }

      // Pentagram
      if(settings.showPentagram){
        const order = [0,2,4,1,3,0];
        let d = "";
        for(let i=0; i<order.length; i++){
          const pt = primals[order[i]];
          d += (i === 0) ? `M ${pt.x} ${pt.y}` : ` L ${pt.x} ${pt.y}`;
        }
        const path = svgEl("path", { d, class: "lw-pentagram" });
        gGeom.appendChild(path);
      }

      // ----- LABEL LAYER (layer 2) -----
      if(settings.showClasses.primalVowels){
        for(const p of primals){
          drawText(gLbls, p.x, p.y, p.label, "lw-label");
        }
      }

      // Monad label (LBL)
      if(settings.showClasses.monad){
        drawText(gLbls, monadX, monadY, settings.monad.label, "lw-monad-label");
      }
    });
  };
})(jQuery);

// INIT: primal elements + monad E
$(function(){
  $("#wheel").languageWheel({
    unitRadiusPx: 300,
    svgPadFactor: 0.10,
    circleBg: "#f0f8ff",
    circleBorder: "#1a1a1a",
    showClasses: { primalVowels: true, monad: true },
    showCenterCross: true,
    showRadials: true,
    showTicks: true,
    showPentagram: true,
    showCenterDot: true,
    monad: {
      label: "E",
      offset: -1/3,
      rxFactor: 0.090,  // tweak freely
      ryFactor: 0.065
    }
  });
});
</script>
</body>
</html>
